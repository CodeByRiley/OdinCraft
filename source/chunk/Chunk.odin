package chunk

import "../blocks"
import rl   "vendor:raylib"
import rlgl "vendor:raylib/rlgl"
import mem "core:mem"
import fmt "core:fmt"
import "../shared"
import "../helpers"

// ───────────────────────────── Config ─────────────────────────────
CHUNK_SIZE_X :: 32  // The width of a chunk in blocks.
CHUNK_SIZE_Z :: 32  // The depth of a chunk in blocks.
CHUNK_SIZE_Y :: 256 // The height of a chunk in blocks.

Face :: blocks.Face // Re-export the Face enum for convenience.

// ───────────────────────────── Types ─────────────────────────────

// World is the top-level container for the entire game world. It holds a map
// of all loaded chunks and global assets like the texture atlas.
World :: struct {
	chunks:    map[[2]int] ^Chunk, // A map from chunk coordinates [cx, cz] to a Chunk pointer.
	atlas:     blocks.Atlas,       // The atlas definition used for UV calculations.
	atlas_tex: rl.Texture2D,       // The actual GPU texture for the block atlas.
}

// Chunk represents a vertical column of blocks (e.g., 32x256x32) in the world.
// It contains the block data, its position, and the renderable mesh.
Chunk :: struct {
	blocks: [CHUNK_SIZE_X][CHUNK_SIZE_Z][CHUNK_SIZE_Y] blocks.BlockType, // 3D array of block IDs.
	cx, cz: int,      // The chunk's coordinates in the world grid.
	world:  ^World,   // A pointer back to the parent world.

	// GPU data for solid, opaque blocks.
	mesh:  rl.Mesh,
    model: rl.Model,

    water_mesh:  rl.Mesh,
    water_model: rl.Model,

    // NEW: arrays of sub-models
    models_opaque: [dynamic]rl.Model,
    models_water:  [dynamic]rl.Model,

    dirty: bool,
    alive: bool,
}

// MeshGeometry holds all the CPU-side vertex data for a chunk's mesh.
// This is generated by a worker thread.


// ───────────────────────────── Utils ─────────────────────────────

// in_bounds checks if a given (x, y, z) coordinate is within the local bounds of a chunk.
in_bounds :: proc(x, y, z: int) -> bool {
	return x >= 0 && x < CHUNK_SIZE_X &&
	       y >= 0 && y < CHUNK_SIZE_Y &&
	       z >= 0 && z < CHUNK_SIZE_Z
}

// make_rl_copy allocates memory using Raylib's internal allocator and copies the
// contents of a slice into it. This is necessary for mesh data that will be
// managed by Raylib's `UploadMesh` and `UnloadMesh` functions.
make_rl_copy :: proc($T: typeid, src: []T) -> ^T {
	n := len(src)
	if n == 0 do return nil
	total := cast(u32)(n * size_of(T))
	p := cast(^T) rl.MemAlloc(total)
	dst := mem.slice_ptr(p, n)
	for i in 0..<n do dst[i] = src[i]
	return p
}

// FaceInfo stores the pre-calculated geometry for a single cube face.
FaceInfo :: struct {
	nrm:     rl.Vector3,   // The normal vector of the face.
	corners: [4]rl.Vector3, // The 4 corner vertices of the face, in counter-clockwise order.
}

// FACE_DATA is a lookup table containing the geometry for all 6 faces of a unit cube.
// Using this table is much faster than calculating the vertices and normals on the fly.
FACE_DATA := [6]FaceInfo{
	{ nrm = {+1,0,0}, corners = [4]rl.Vector3{{1,0,0},{1,1,0},{1,1,1},{1,0,1}} }, // Positive X
	{ nrm = {-1,0,0}, corners = [4]rl.Vector3{{0,0,1},{0,1,1},{0,1,0},{0,0,0}} }, // Negative X
	{ nrm = {0,+1,0}, corners = [4]rl.Vector3{{0,1,1},{1,1,1},{1,1,0},{0,1,0}} }, // Positive Y (Top)
	{ nrm = {0,-1,0}, corners = [4]rl.Vector3{{0,0,0},{1,0,0},{1,0,1},{0,0,1}} }, // Negative Y (Bottom)
	{ nrm = {0,0,+1}, corners = [4]rl.Vector3{{0,0,1},{1,0,1},{1,1,1},{0,1,1}} }, // Positive Z
	{ nrm = {0,0,-1}, corners = [4]rl.Vector3{{1,0,0},{0,0,0},{0,1,0},{1,1,0}} }, // Negative Z
}

// NEI is a lookup table of the 6 neighbor block offsets, used for face culling.
NEI := [6][3]int{
	{+1,0,0},{-1,0,0}, // Right, Left
	{0,+1,0},{0,-1,0}, // Top, Bottom
	{0,0,+1},{0,0,-1}, // Front, Back
}

// Pre-defined vertex colors used to tint certain textures.
GRASS_TINT  := rl.Color{118,182,76,255}
LEAVES_TINT := rl.Color{127,178,56,255}
WATER_TINT  := rl.Color{63,118,228,180} // Note the lower alpha for transparency.

// face_tint returns a specific color for certain block faces (e.g., green for grass tops)
// or returns white (no tint) for all other blocks.
face_tint :: proc(bt: blocks.BlockType, face: Face) -> rl.Color {
	if bt == blocks.BlockType.Grass && face == Face.PY {
		return GRASS_TINT
	}
	if bt == blocks.BlockType.OakLeaves do return LEAVES_TINT
	if bt == blocks.BlockType.Water     do return WATER_TINT
	return rl.WHITE // Default: no tint.
}

// ───────────────────────────── World API ─────────────────────────
// world_init initializes a new World struct.
world_init :: proc(w: ^World, inset_px: u16 = 0.0) {
	w.chunks = make(map[[2]int] ^Chunk)
	w.atlas  = blocks.atlas_make(inset_px)
}

// world_add_chunk adds a chunk to the world's chunk map and sets its parent world pointer.
world_add_chunk :: proc(w: ^World, c: ^Chunk) {
	w.chunks[[2]int{c.cx, c.cz}] = c
	c.world = w
}

// world_get_chunk safely retrieves a chunk from the world map at the given chunk coordinates.
// Returns nil if the chunk is not loaded.
world_get_chunk :: proc(w: ^World, cx, cz: int) -> ^Chunk {
	if w == nil do return nil
	if c, ok := w.chunks[[2]int{cx, cz}]; ok { return c }
	return nil
}

// world_set_atlas_texture assigns the GPU texture to the world and applies
// recommended texture filtering for pixel art.
world_set_atlas_texture :: proc(w: ^World, tex: rl.Texture2D) {
	w.atlas_tex = tex
	rl.SetTextureFilter(tex, rl.TextureFilter.POINT)
}

// ───────────────────────────── Chunk API ─────────────────────────
// chunk_init initializes a new Chunk at the given chunk coordinates,
// setting its block data to Air by default.
chunk_init :: proc(c: ^Chunk, cx, cz: int) {
	c.cx = cx; c.cz = cz
	c.dirty = true
	c.mesh  = rl.Mesh{}
	c.model = rl.Model{}

	// Ensure new chunks start empty to avoid a "shell" of default blocks.
	for x in 0..<CHUNK_SIZE_X {
		for z in 0..<CHUNK_SIZE_Z {
			for y in 0..<CHUNK_SIZE_Y {
				c.blocks[x][z][y] = blocks.BlockType.Air
			}
		}
	}
}

// chunk_set places a block of a given type at the specified local coordinates
// within the chunk and marks the chunk as dirty.
chunk_set :: proc(c: ^Chunk, x, y, z: int, bt: blocks.BlockType) {
	if !in_bounds(x,y,z) do return
	c.blocks[x][z][y] = bt
	c.dirty = true
}

// chunk_get retrieves the block type at the specified local coordinates.
// Returns Air if the coordinates are out of bounds.
chunk_get :: proc(c: ^Chunk, x, y, z: int) -> blocks.BlockType {
	if !in_bounds(x,y,z) do return blocks.BlockType.Air
	return c.blocks[x][z][y]
}

// chunk_set_layer sets an entire horizontal layer of a chunk to a specific block type.
chunk_set_layer :: proc(c: ^Chunk, y: int, bt: blocks.BlockType) {
	if y < 0 || y >= CHUNK_SIZE_Y { return }
	for x in 0..<CHUNK_SIZE_X {
		for z in 0..<CHUNK_SIZE_Z {
			c.blocks[x][z][y] = bt
		}
	}
	c.dirty = true
}

// chunk_fill_to_height fills a chunk with a block type from Y=0 up to and including H.
chunk_fill_to_height :: proc(c: ^Chunk, h: int, bt: blocks.BlockType) {
	// Clamp height to be within chunk bounds.
	H := h
	if H < 0           { H = 0 }
	if H >= CHUNK_SIZE_Y { H = CHUNK_SIZE_Y - 1 }

	for x in 0..<CHUNK_SIZE_X {
		for z in 0..<CHUNK_SIZE_Z {
			for y in 0..=H {
				c.blocks[x][z][y] = bt
			}
		}
	}
	c.dirty = true
}

// get_block_world safely retrieves a block at local chunk coordinates. If the coordinates
// are outside the current chunk, it calculates the correct neighbor chunk and samples from it.
// Returns Air if the neighbor chunk isn't loaded.
get_block_world :: proc(c: ^Chunk, lx, ly, lz: int) -> blocks.BlockType {
	// Fast path for blocks within the current chunk.
	if in_bounds(lx,ly,lz) do return c.blocks[lx][lz][ly]
	// Fast path for out-of-bounds Y coordinates.
	if ly < 0 || ly >= CHUNK_SIZE_Y do return blocks.BlockType.Air

	// Calculate the neighbor chunk coordinates (nx, nz) and the new local coordinates (gx, gz).
	nx := c.cx; nz := c.cz
	gx := lx;   gz := lz
	for gx < 0           { gx += CHUNK_SIZE_X; nx -= 1 }
	for gx >= CHUNK_SIZE_X { gx -= CHUNK_SIZE_X; nx += 1 }
	for gz < 0           { gz += CHUNK_SIZE_Z; nz -= 1 }
	for gz >= CHUNK_SIZE_Z { gz -= CHUNK_SIZE_Z; nz += 1 }

	// Get the neighbor chunk from the world.
	nbor := world_get_chunk(c.world, nx, nz)
	if nbor == nil do return blocks.BlockType.Air // If neighbor isn't loaded, treat it as air.
	return nbor.blocks[gx][gz][ly]
}

// is_solid is a helper for the culling algorithm, defining which block types hide adjacent faces.
is_solid :: proc(bt: blocks.BlockType) -> bool {
	// Water is not solid, so solid blocks will be visible through it.
	return bt != blocks.BlockType.Air &&
	       bt != blocks.BlockType.Water
}

// get_uv_for is a convenience wrapper to get the UV coordinates for a specific block face.
get_uv_for :: proc(atlas: ^blocks.Atlas, bt: blocks.BlockType, face: Face) -> (u0,v0,u1,v1: f32) {
	cell := blocks.tile_for_face(bt, face)
	r    := blocks.atlas_uv_rect(atlas, cell)
	return r.u0, r.v0, r.u1, r.v1
}

// chunk_unload_gpu frees any GPU memory (Meshes and Models) associated with this chunk.
// This must be called before rebuilding a mesh to prevent memory leaks.
chunk_unload_gpu :: proc(c: ^Chunk) {
    // Unload arrays first
    for i in 0..<len(c.models_opaque) {
        if c.models_opaque[i].meshCount > 0 {
            rl.UnloadModel(c.models_opaque[i])
        }
    }
    delete(c.models_opaque)

    for i in 0..<len(c.models_water) {
        if c.models_water[i].meshCount > 0 {
            rl.UnloadModel(c.models_water[i])
        }
    }
    delete(c.models_water)

    // Unload any “current part” models
    if c.model.meshCount > 0 {
        rl.UnloadModel(c.model)
        c.model = rl.Model{}
        c.mesh  = rl.Mesh{}
    } else if c.mesh.vertexCount > 0 {
        rl.UnloadMesh(c.mesh)
        c.mesh = rl.Mesh{}
    }

    if c.water_model.meshCount > 0 {
        rl.UnloadModel(c.water_model)
        c.water_model = rl.Model{}
        c.water_mesh  = rl.Mesh{}
    } else if c.water_mesh.vertexCount > 0 {
        rl.UnloadMesh(c.water_mesh)
        c.water_mesh = rl.Mesh{}
    }
}

// get_chunk_aabb calculates the world-space Axis-Aligned Bounding Box for this chunk.
// Used for frustum culling.
get_chunk_aabb :: proc(c: ^Chunk) -> rl.BoundingBox {
	wx := f32(c.cx) * f32(CHUNK_SIZE_X)
	wz := f32(c.cz) * f32(CHUNK_SIZE_Z)

	min := rl.Vector3{wx, 0, wz}
	max := rl.Vector3{
		wx + f32(CHUNK_SIZE_X), 
		f32(CHUNK_SIZE_Y), 
		wz + f32(CHUNK_SIZE_Z),
	}

	return rl.BoundingBox{min, max}
}

MAX_PART_VERTS : i32 = 60000
flush_to_model :: proc(
    mesh: ^rl.Mesh, model: ^rl.Model,
    verts: ^[dynamic]f32, norms: ^[dynamic]f32, uvs: ^[dynamic]f32,
    cols: ^[dynamic]u8,  idx:   ^[dynamic]u16,
    atlas_tex: rl.Texture2D,
) -> (out: rl.Model, ok: bool) {
    if len(idx^) == 0 {
        return rl.Model{}, false
    }

    mesh.vertexCount   = cast(i32)(len(verts^) / 3)
    mesh.triangleCount = cast(i32)(len(idx^)   / 3)

    mesh.vertices  = make_rl_copy(f32, (verts^)[:])
    mesh.normals   = make_rl_copy(f32, (norms^)[:])
    mesh.texcoords = make_rl_copy(f32, (uvs^)[:])
    mesh.colors    = make_rl_copy(u8,  (cols^)[:])
    mesh.indices   = make_rl_copy(u16, (idx^)[:])

    rl.UploadMesh(mesh, true)
    m := rl.LoadModelFromMesh(mesh^)
    if atlas_tex.id != 0 {
        rl.SetMaterialTexture(&m.materials[0], rl.MaterialMapIndex.ALBEDO, atlas_tex)
    }

    // clear CPU buffers for next part
    delete(verts^); delete(norms^); delete(uvs^); delete(cols^); delete(idx^)

    // clear transient mesh so chunk_unload_gpu won't double-free it
    mesh^ = rl.Mesh{}

    return m, true
}

// chunk_update_mesh rebuilds the chunk's renderable mesh from its block data if it is marked as 'dirty'.
chunk_update_mesh :: proc(c: ^Chunk) {
    if !c.dirty do return
    c.dirty = false

    // 1) start clean
    chunk_unload_gpu(c)

    // 2) scratch buffers (opaque/water)
    vertsO: [dynamic]f32; normsO: [dynamic]f32; uvsO: [dynamic]f32; colorsO: [dynamic]u8; idxO: [dynamic]u16
    vertsW: [dynamic]f32; normsW: [dynamic]f32; uvsW: [dynamic]f32; colorsW: [dynamic]u8; idxW: [dynamic]u16

    for x in 0..<CHUNK_SIZE_X {
        for z in 0..<CHUNK_SIZE_Z {
            for y in 0..<CHUNK_SIZE_Y {
                bt := c.blocks[x][z][y]
                if bt == blocks.BlockType.Air do continue
                is_water := bt == blocks.BlockType.Water

                for f in 0..<6 {
                    nx := x + NEI[f][0]
                    ny := y + NEI[f][1]
                    nz := z + NEI[f][2]
                    nb := get_block_world(c, nx, ny, nz)

                    if !is_water {
                        if is_solid(nb) do continue
                    } else {
                        if nb == blocks.BlockType.Water do continue
                    }

                    vertsP := &vertsO; normsP := &normsO; uvsP := &uvsO; colsP := &colorsO; idxP := &idxO
                    if is_water {
                        vertsP = &vertsW; normsP = &normsW; uvsP = &uvsW; colsP = &colorsW; idxP = &idxW
                    }

                    // split if needed
                    currVerts := cast(i32)(len(vertsP^) / 3)
                    if currVerts + 4 > MAX_PART_VERTS {
                        if is_water {
                            m, ok := flush_to_model(&c.water_mesh, &c.water_model, &vertsW, &normsW, &uvsW, &colorsW, &idxW, c.world.atlas_tex)
                            if ok { append(&c.models_water, m) }
                        } else {
                            m, ok := flush_to_model(&c.mesh, &c.model, &vertsO, &normsO, &uvsO, &colorsO, &idxO, c.world.atlas_tex)
                            if ok { append(&c.models_opaque, m) }
                        }
                    }

                    face := FACE_DATA[f]
                    base := cast(u16)(len(vertsP^) / 3)

                    u0, v0, u1, v1 := get_uv_for(&c.world.atlas, bt, cast(Face)f)

                    for k in 0..<4 {
                        co := face.corners[k]
                        px := cast(f32)(c.cx*CHUNK_SIZE_X + x) + co.x
                        py := cast(f32)(y)                    + co.y
                        pz := cast(f32)(c.cz*CHUNK_SIZE_Z + z) + co.z
                        append(vertsP, px); append(vertsP, py); append(vertsP, pz)
                        append(normsP, face.nrm.x); append(normsP, face.nrm.y); append(normsP, face.nrm.z)

                        s, t: f32
                        switch f {
                        case 0: s = co.z;        t = 1.0 - co.y
                        case 1: s = 1.0 - co.z;  t = 1.0 - co.y
                        case 2: s = co.x;        t = co.z
                        case 3: s = co.x;        t = 1.0 - co.z
                        case 4: s = 1.0 - co.x;  t = 1.0 - co.y
                        case 5: s = co.x;        t = 1.0 - co.y
                        }
                        u := u0 + (u1 - u0)*s
                        v := v0 + (v1 - v0)*t
                        append(uvsP, u); append(uvsP, v)

                        col := face_tint(bt, cast(Face)f)
                        append(colsP, col.r); append(colsP, col.g); append(colsP, col.b); append(colsP, col.a)
                    }

                    append(idxP, base+0); append(idxP, base+1); append(idxP, base+2)
                    append(idxP, base+0); append(idxP, base+2); append(idxP, base+3)
                }
            }
        }
    }

    // final flush (leftovers)
    if len(idxO) > 0 {
        m, ok := flush_to_model(&c.mesh, &c.model, &vertsO, &normsO, &uvsO, &colorsO, &idxO, c.world.atlas_tex)
        if ok { append(&c.models_opaque, m) }
    }
    if len(idxW) > 0 {
        m, ok := flush_to_model(&c.water_mesh, &c.water_model, &vertsW, &normsW, &uvsW, &colorsW, &idxW, c.world.atlas_tex)
        if ok { append(&c.models_water, m) }
    }

    // make sure no “current part” models stick around
    c.model = rl.Model{};     c.mesh = rl.Mesh{}
    c.water_model = rl.Model{}; c.water_mesh = rl.Mesh{}
}

chunk_build_geometry :: proc(c: ^Chunk) -> ^shared.MeshGeometry {
    geo := new(shared.MeshGeometry)

    // The entire 'for x/z/y' loop from your old chunk_update_mesh goes here.
    // It populates the dynamic arrays inside the 'geo' struct.
    for x in 0..<CHUNK_SIZE_X {
        for z in 0..<CHUNK_SIZE_Z {
            for y in 0..<CHUNK_SIZE_Y {
                bt := c.blocks[x][z][y]
                if bt == blocks.BlockType.Air do continue
                is_water := bt == blocks.BlockType.Water

                for f in 0..<6 {
                    // ... (the entire face culling and vertex generation logic is identical)
                    // Just make sure to append to the correct arrays in the 'geo' struct, for example:
                    // vertsP := &geo.vertsO 
                    // ...
                    // append(vertsP, px, py, pz)
                    
                    nx := x + NEI[f][0]; ny := y + NEI[f][1]; nz := z + NEI[f][2]
                    nb := get_block_world(c, nx, ny, nz)

                    if !is_water {
                        if is_solid(nb) do continue
                    } else {
                        if nb == blocks.BlockType.Water do continue
                    }

                    vertsP  := &geo.vertsO;  normsP := &geo.normsO; uvsP := &geo.uvsO
                    colorsP := &geo.colorsO; idxP := &geo.idxO
                    if is_water {
                        vertsP = &geo.vertsW;   normsP = &geo.normsW;  uvsP = &geo.uvsW
                        colorsP = &geo.colorsW; idxP = &geo.idxW
                    }
                    

                    face := FACE_DATA[f]
                    base := cast(u16)(len(vertsP^) / 3)
                    u0, v0, u1, v1 := get_uv_for(&c.world.atlas, bt, cast(Face)f)
                    
                     for k in 0..<4 {
                        co := face.corners[k]
                        px := cast(f32)(c.cx*CHUNK_SIZE_X + x) + co.x
                        py := cast(f32)(y)                         + co.y
                        pz := cast(f32)(c.cz*CHUNK_SIZE_Z + z) + co.z
                        append(vertsP, px); append(vertsP, py); append(vertsP, pz)
                        append(normsP, face.nrm.x); append(normsP, face.nrm.y); append(normsP, face.nrm.z)

                        s, t: f32
                        switch f {
                        case 0: s = co.z;         t = 1.0 - co.y
                        case 1: s = 1.0 - co.z;   t = 1.0 - co.y
                        case 2: s = co.x;         t = co.z
                        case 3: s = co.x;         t = 1.0 - co.z
                        case 4: s = 1.0 - co.x;   t = 1.0 - co.y
                        case 5: s = co.x;         t = 1.0 - co.y
                        }
                        u := u0 + (u1 - u0)*s
                        v := v0 + (v1 - v0)*t
                        append(uvsP, u); append(uvsP, v)

                        col := face_tint(bt, cast(Face)f)
                        append(colorsP, col.r); append(colorsP, col.g); append(colorsP, col.b); append(colorsP, col.a)
                    }

                    append(idxP, base+0); append(idxP, base+1); append(idxP, base+2)
                    append(idxP, base+0); append(idxP, base+2); append(idxP, base+3)
                }
            }
        }
    }
    return geo
}

chunk_upload_geometry :: proc(c: ^Chunk, geo: ^shared.MeshGeometry) {
    chunk_unload_gpu(c)

    // Upload opaque mesh
    if len(geo.idxO) > 0 {
        c.mesh.vertexCount   = cast(i32)(len(geo.vertsO)/3)
        c.mesh.triangleCount = cast(i32)(len(geo.idxO)/3)
        c.mesh.vertices      = make_rl_copy(f32, geo.vertsO[:])
        c.mesh.normals       = make_rl_copy(f32, geo.normsO[:])
        c.mesh.texcoords     = make_rl_copy(f32, geo.uvsO[:])
        c.mesh.colors        = make_rl_copy(u8,  geo.colorsO[:])
        c.mesh.indices       = make_rl_copy(u16, geo.idxO[:])
        rl.UploadMesh(&c.mesh, false) // `false` for static mesh
        c.model = rl.LoadModelFromMesh(c.mesh)
        rl.SetMaterialTexture(&c.model.materials[0], rl.MaterialMapIndex.ALBEDO, c.world.atlas_tex)
    }

    // Upload water mesh
    if len(geo.idxW) > 0 {
        c.water_mesh.vertexCount   = cast(i32)(len(geo.vertsW)/3)
        c.water_mesh.triangleCount = cast(i32)(len(geo.idxW)/3)
        c.water_mesh.vertices      = make_rl_copy(f32, geo.vertsW[:])
        // ... (etc. for water mesh, same as opaque)
        c.water_mesh.normals       = make_rl_copy(f32, geo.normsW[:])
        c.water_mesh.texcoords     = make_rl_copy(f32, geo.uvsW[:])
        c.water_mesh.colors        = make_rl_copy(u8,  geo.colorsW[:])
        c.water_mesh.indices       = make_rl_copy(u16, geo.idxW[:])
        rl.UploadMesh(&c.water_mesh, false)
        c.water_model = rl.LoadModelFromMesh(c.water_mesh)
        rl.SetMaterialTexture(&c.water_model.materials[0], rl.MaterialMapIndex.ALBEDO, c.world.atlas_tex)
    }

    // Free the temporary geometry data
    delete(geo.vertsO); delete(geo.normsO); delete(geo.uvsO); delete(geo.colorsO); delete(geo.idxO)
    delete(geo.vertsW); delete(geo.normsW); delete(geo.uvsW); delete(geo.colorsW); delete(geo.idxW)
    free(geo)

    c.dirty = false // Mark the chunk as clean
}


// TerrainParams holds all the configurable parameters for procedural world generation.
TerrainParams :: struct {
	// Heightmap parameters
	scale:       f32, // Controls the "zoom" of the terrain noise. Larger values = more stretched out terrain.
	octaves:     int, // Number of noise layers to combine for detail.
	lacunarity:  f32, // Frequency multiplier for each subsequent octave.
	gain:        f32, // Amplitude multiplier for each subsequent octave.
	amplitude:   f32, // The maximum vertical variation of the terrain in blocks.
	sea_level:   int, // The Y-level at which water appears.
	top_soil:    int, // The depth of dirt that appears under grass blocks.

	// Cave generation parameters
	caves:           bool,
	cave_scale:      f32, // Controls the size of the caves.
	cave_octaves:    int,
	cave_lacunarity: f32,
	cave_gain:       f32,
	cave_threshold:  f32, // The noise value above which caves are carved out.

	// Block types to use during generation
	block_stone:  blocks.BlockType,
	block_dirt:   blocks.BlockType,
	block_grass:  blocks.BlockType,
	use_water:    bool,
	block_water:  blocks.BlockType,
}

// default_terrain_params provides a good starting set of parameters for generating interesting terrain.
default_terrain_params :: proc() -> TerrainParams {
	return TerrainParams{
		scale       = 128.0,
		octaves     = 5,
		lacunarity  = 2.0,
		gain        = 0.5,
		amplitude   = 40.0,
		sea_level   = 62,
		top_soil    = 3,

		caves           = true,
		cave_scale      = 96.0,
		cave_octaves    = 3,
		cave_lacunarity = 2.0,
		cave_gain       = 0.5,
		cave_threshold  = 0.55,

		block_stone = blocks.BlockType.Stone,
		block_dirt  = blocks.BlockType.Dirt,
		block_grass = blocks.BlockType.Grass,
		block_water = blocks.BlockType.Water,
		use_water   = false,
	}
}

// ───────────────────────────── Chunk generation ─────────────────────────────

// chunk_generate_perlin fills a chunk's block data using multi-layered Perlin noise (fBm).
// It creates a heightmap-based terrain with stone, dirt, grass, optional water, and optional caves.
chunk_generate_perlin :: proc(c: ^Chunk, noise: ^helpers.Perlin, seed: u32, params: TerrainParams) {
	// First pass: Fill with stone and water
	if c.cx == 0 && c.cz == 0 {
        fmt.printf("--- Generating chunk (0,0) ---\n")
        fmt.printf("Params received: Stone=%v, Dirt=%v, Grass=%v\n", params.block_stone, params.block_dirt, params.block_grass)
    }
	heights: [CHUNK_SIZE_X][CHUNK_SIZE_Z]int
	for x in 0..<CHUNK_SIZE_X {
		for z in 0..<CHUNK_SIZE_Z {
			gx := c.cx*CHUNK_SIZE_X + x
			gz := c.cz*CHUNK_SIZE_Z + z
			nx := cast(f32)(gx) / params.scale
			nz := cast(f32)(gz) / params.scale

			hnoise := helpers.fbm2(noise, nx, nz, params.octaves, params.lacunarity, params.gain)
			height := params.sea_level + cast(int)(params.amplitude * hnoise)
			if height < 1 { height = 1 }
			if height > CHUNK_SIZE_Y-2 { height = CHUNK_SIZE_Y-2 }
			heights[x][z] = height

			for y in 0..=height {
				c.blocks[x][z][y] = params.block_stone
			}

			if params.use_water && params.sea_level > height {
				for y in height+1 ..= params.sea_level {
					if y >= 0 && y < CHUNK_SIZE_Y {
						c.blocks[x][z][y] = params.block_water
					}
				}
			}
		}
	}

	// Second pass: Carve out caves using 3D Perlin noise
	if params.caves {
		inv := 1.0 / params.cave_scale
		for x in 0..<CHUNK_SIZE_X {
			for z in 0..<CHUNK_SIZE_Z {
				top := heights[x][z]
				for y in 1..=top {
					nx := cast(f32)(c.cx*CHUNK_SIZE_X + x) * inv
					ny := cast(f32)(y)                         * inv
					nz := cast(f32)(c.cz*CHUNK_SIZE_Z + z) * inv
					n3 := helpers.fbm3(noise, nx, ny, nz, params.cave_octaves, params.cave_lacunarity, params.cave_gain)
					if n3 > params.cave_threshold {
						c.blocks[x][z][y] = blocks.BlockType.Air
					}
				}
			}
		}
	}

	// Place top soil
	for x in 0..<CHUNK_SIZE_X {
        for z in 0..<CHUNK_SIZE_Z {
            y := CHUNK_SIZE_Y - 1
            for y >= 1 {
                if c.blocks[x][z][y] != blocks.BlockType.Air do break
                y -= 1
            }
            if y < 1 do continue

            surface_block_type := c.blocks[x][z][y]
            
            // Check a single column to see what surface it finds.
            if c.cx == 0 && c.cz == 0 && x == 16 && z == 16 {
                fmt.printf("Column(16,16): Surface found at y=%v. Block type is %v.\n", y, surface_block_type)
            }

            if surface_block_type == params.block_stone {
                if c.cx == 0 && c.cz == 0 && x == 16 && z == 16 {
                    fmt.printf("  > Surface is stone. Placing grass.\n")
                }

                c.blocks[x][z][y] = params.block_grass

                for d in 1..=params.top_soil {
                    yy := y - d
                    if yy <= 0 do break
                    if c.blocks[x][z][yy] == params.block_stone {
                        c.blocks[x][z][yy] = params.block_dirt
                    }
                }
            } else {
                if c.cx == 0 && c.cz == 0 && x == 16 && z == 16 {
                    fmt.printf("  > Surface is NOT stone (%v). Skipping grass placement.\n", surface_block_type)
                }
            }
        }
    }
	c.dirty = true // Mark the chunk for remeshing.
}

// chunk_draw_opaque renders the chunk's main solid model.
chunk_draw_opaque :: proc(c: ^Chunk) {
    for m in c.models_opaque {
        rl.DrawModel(m, rl.Vector3{0,0,0}, 1.0, rl.WHITE)
    }
    if c.model.meshCount > 0 {
        rl.DrawModel(c.model, rl.Vector3{0,0,0}, 1.0, rl.WHITE)
    }
}

chunk_draw_water :: proc(c: ^Chunk) {
    rl.BeginBlendMode(rl.BlendMode.ALPHA)
    rlgl.DisableDepthMask()
    for m in c.models_water {
        rl.DrawModel(m, rl.Vector3{0,0,0}, 1.0, rl.WHITE)
    }
    if c.water_model.meshCount > 0 {
        rl.DrawModel(c.water_model, rl.Vector3{0,0,0}, 1.0, rl.WHITE)
    }
    rlgl.EnableDepthMask()
    rl.EndBlendMode()
}